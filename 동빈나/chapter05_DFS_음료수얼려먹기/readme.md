# 이것이 취업을 위한 코딩 테스트다
* 제목: 음료수 얼려먹기
* 문제: 얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램
* 유형: DFS/BFS
* 날짜: 2021-04-26

## 풀이 알고리즘
해당 문제를 풀기 위해 DFS(깊이우선탐색) 알고리즘을 사용했다. <br>
<b> 현재 위치한 노드를 기준으로 상,하,좌,우에 있는 노드를 살펴보는데 그 노드가 구멍(0)이면서 방문하지 않았다면 재귀적으로 탐색을 진행했다. </b>
1. 현재 위치에서 방문한 적이 없거나 구멍이라면 DFS를 시작한다.
2. 인접 노드(구멍)을 상하좌우로 탐색한다.
3. 배열의 범위를 초과하지 않고, 방문하지 않은 구멍이라면 해당 인접 노드를 기준으로 다시 인접 노드를 탐색한다.(재귀 DFS)
4. 1~3번까지 한 루프를 돌고 부분 탐색이 끝나면 아이스크림 생성 개수를 증가한다.
5. 칸막이 넘어의 구멍을 모두 조사할때까지 1~4번까지의 행동을 계속해서 반복한다.

## 고찰
DFS와 BFS는 계속해서 생각하고 염두해두지 않는다면 흘러가는 것을 파악하기가 어려운 것 같다. 꾸준한 연습이 필요할 것 같다.
특히, 인접 노드를 탐색해 나가는 과정에서 재귀적 호출 방식을 파악하지 못한다면 재귀 호출에 대해 확실한 이해를 하고 넘어가야 한다.
재귀 함수는 <b>자기 자신을 다시 호출하는 함수</b>이며,
컴퓨터 내부에서 재귀 함수의 수행은 스택 자료구조를 이용하기 때문에 <b>가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수 호출이 이루어 진다.</b><br>
<b>즉, 맨 밑 바닥까지 갔다가 올라오면서 처리가 된다는 말이다.</b>
이 점을 유의하며 코테 준비를 하도록 하자.

## 팁
* scanf("%1d",&graph[i])와 같이 %1d를 사용하면 숫자들이 공백 없이 연속적으로 붙어있어도 한 번에 한 개씩 입력받을 수 있다.
```cpp
ex)  input: 00100  <- 입력
     scanf("%1d", &graph[i]);
결과: graph = [0,0,1,0,0]
```

## 결론
* 더 많은 문제를 풀어보며 알고리즘을 숙지해야 할 것 같다.
